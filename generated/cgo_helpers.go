// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

import (
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	panic("")
}

func (a *cgoAllocMap) IsEmpty() bool {
	panic("")
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	panic("")
}

func (a *cgoAllocMap) Free() {
	panic("")
}

// allocFilBLSSignatureMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilBLSSignatureMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilBLSSignatureValue = unsafe.Sizeof([1]byte{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSSignature) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSSignature) Free() {
	panic("")
}

// NewFilBLSSignatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSSignatureRef(ref unsafe.Pointer) *FilBLSSignature {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSSignature) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSSignature) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSSignature) Deref() {
	panic("")
}

// allocFilAggregateResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilAggregateResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilAggregateResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilAggregateResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilAggregateResponse) Free() {
	panic("")
}

// NewFilAggregateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilAggregateResponseRef(ref unsafe.Pointer) *FilAggregateResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilAggregateResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilAggregateResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilAggregateResponse) Deref() {
	panic("")
}

// allocFilClearCacheResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilClearCacheResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilClearCacheResponseValue = unsafe.Sizeof([1]interface{}{})

// unpackPCharString represents the data from Go string as interface{} and avoids copying.
func unpackPCharString(str string) (interface{}, *cgoAllocMap) {
	panic("")
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	panic("")
}

// packPCharString creates a Go string backed by interface{} and avoids copying.
func packPCharString(p interface{}) (raw string) {
	panic("")
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	panic("")
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilClearCacheResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilClearCacheResponse) Free() {
	panic("")
}

// NewFilClearCacheResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilClearCacheResponseRef(ref unsafe.Pointer) *FilClearCacheResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilClearCacheResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilClearCacheResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilClearCacheResponse) Deref() {
	panic("")
}

// allocFilFauxRepResponseMemory allocates memory for type C.fil_FauxRepResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilFauxRepResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilFauxRepResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilFauxRepResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilFauxRepResponse) Free() {
	panic("")
}

// NewFilFauxRepResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilFauxRepResponseRef(ref unsafe.Pointer) *FilFauxRepResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilFauxRepResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilFauxRepResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilFauxRepResponse) Deref() {
	panic("")
}

// allocFilFinalizeTicketResponseMemory allocates memory for type C.fil_FinalizeTicketResponse in C.
// The caller is responsible for freeing the this memory via C.free.
// allocFilFinalizeTicketResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilFinalizeTicketResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilFinalizeTicketResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilFinalizeTicketResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilFinalizeTicketResponse) Free() {
	panic("")
}

// NewFilFinalizeTicketResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilFinalizeTicketResponseRef(ref unsafe.Pointer) *FilFinalizeTicketResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilFinalizeTicketResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilFinalizeTicketResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilFinalizeTicketResponse) Deref() {
	panic("")
}

// allocFilGenerateDataCommitmentResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilGenerateDataCommitmentResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilGenerateDataCommitmentResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateDataCommitmentResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateDataCommitmentResponse) Free() {
	panic("")
}

// NewFilGenerateDataCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateDataCommitmentResponseRef(ref unsafe.Pointer) *FilGenerateDataCommitmentResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateDataCommitmentResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateDataCommitmentResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateDataCommitmentResponse) Deref() {
	panic("")
}

// allocFilGeneratePieceCommitmentResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilGeneratePieceCommitmentResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilGeneratePieceCommitmentResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGeneratePieceCommitmentResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGeneratePieceCommitmentResponse) Free() {
	panic("")
}

// NewFilGeneratePieceCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGeneratePieceCommitmentResponseRef(ref unsafe.Pointer) *FilGeneratePieceCommitmentResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGeneratePieceCommitmentResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGeneratePieceCommitmentResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGeneratePieceCommitmentResponse) Deref() {
	panic("")
}

// allocFilPoStProofMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPoStProofMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPoStProofValue = unsafe.Sizeof([1]interface{}{})

// unpackPUint8TString represents the data from Go string as interface{} and avoids copying.
func unpackPUint8TString(str string) (interface{}, *cgoAllocMap) {
	panic("")
}

// packPUint8TString creates a Go string backed by interface{} and avoids copying.
func packPUint8TString(p interface{}) (raw string) {
	panic("")
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPoStProof) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPoStProof) Free() {
	panic("")
}

// NewFilPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPoStProofRef(ref unsafe.Pointer) *FilPoStProof {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPoStProof) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPoStProof) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPoStProof) Deref() {
	panic("")
}

// allocFilGenerateWindowPoStResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilGenerateWindowPoStResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilGenerateWindowPoStResponseValue = unsafe.Sizeof([1]interface{}{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSFilPoStProof transforms a sliced Go data structure into plain C format.
func unpackSFilPoStProof(x []FilPoStProof) (unpacked interface{}, allocs *cgoAllocMap) {
	panic("")
}

// packSFilPoStProof reads sliced Go data structure out from plain C format.
func packSFilPoStProof(v []FilPoStProof, ptr0 interface{}) {
	panic("")
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWindowPoStResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWindowPoStResponse) Free() {
	panic("")
}

// NewFilGenerateWindowPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWindowPoStResponseRef(ref unsafe.Pointer) *FilGenerateWindowPoStResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWindowPoStResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWindowPoStResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWindowPoStResponse) Deref() {
	panic("")
}

// allocFilGenerateWinningPoStResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilGenerateWinningPoStResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilGenerateWinningPoStResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWinningPoStResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWinningPoStResponse) Free() {
	panic("")
}

// NewFilGenerateWinningPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWinningPoStResponseRef(ref unsafe.Pointer) *FilGenerateWinningPoStResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWinningPoStResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWinningPoStResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWinningPoStResponse) Deref() {
	panic("")
}

// allocFilGenerateWinningPoStSectorChallengeMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilGenerateWinningPoStSectorChallengeMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilGenerateWinningPoStSectorChallengeValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateWinningPoStSectorChallenge) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateWinningPoStSectorChallenge) Free() {
	panic("")
}

// NewFilGenerateWinningPoStSectorChallengeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateWinningPoStSectorChallengeRef(ref unsafe.Pointer) *FilGenerateWinningPoStSectorChallenge {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateWinningPoStSectorChallenge) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateWinningPoStSectorChallenge) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateWinningPoStSectorChallenge) Deref() {
	panic("")
}

// allocFilGpuDeviceResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilGpuDeviceResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilGpuDeviceResponseValue = unsafe.Sizeof([1]interface{}{})

// allocPCharMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocPCharMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfPCharValue = unsafe.Sizeof([1]interface{}{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked *interface{}, allocs *cgoAllocMap) {
	panic("")
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 *interface{}) {
	panic("")
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGpuDeviceResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGpuDeviceResponse) Free() {
	panic("")
}

// NewFilGpuDeviceResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGpuDeviceResponseRef(ref unsafe.Pointer) *FilGpuDeviceResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGpuDeviceResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGpuDeviceResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGpuDeviceResponse) Deref() {
	panic("")
}

// allocFilBLSDigestMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilBLSDigestMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilBLSDigestValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSDigest) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSDigest) Free() {
	panic("")
}

// NewFilBLSDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSDigestRef(ref unsafe.Pointer) *FilBLSDigest {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSDigest) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSDigest) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSDigest) Deref() {
	panic("")
}

// allocFilHashResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilHashResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilHashResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilHashResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilHashResponse) Free() {
	panic("")
}

// NewFilHashResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilHashResponseRef(ref unsafe.Pointer) *FilHashResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilHashResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilHashResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilHashResponse) Deref() {
	panic("")
}

// allocFilInitLogFdResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilInitLogFdResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilInitLogFdResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilInitLogFdResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilInitLogFdResponse) Free() {
	panic("")
}

// NewFilInitLogFdResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilInitLogFdResponseRef(ref unsafe.Pointer) *FilInitLogFdResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilInitLogFdResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilInitLogFdResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilInitLogFdResponse) Deref() {
	panic("")
}

// allocFilBLSPrivateKeyMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilBLSPrivateKeyMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilBLSPrivateKeyValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPrivateKey) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPrivateKey) Free() {
	panic("")
}

// NewFilBLSPrivateKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPrivateKeyRef(ref unsafe.Pointer) *FilBLSPrivateKey {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPrivateKey) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPrivateKey) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPrivateKey) Deref() {
	panic("")
}

// allocFilPrivateKeyGenerateResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPrivateKeyGenerateResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPrivateKeyGenerateResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyGenerateResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyGenerateResponse) Free() {
	panic("")
}

// NewFilPrivateKeyGenerateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyGenerateResponseRef(ref unsafe.Pointer) *FilPrivateKeyGenerateResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyGenerateResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyGenerateResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyGenerateResponse) Deref() {
	panic("")
}

// allocFilBLSPublicKeyMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilBLSPublicKeyMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilBLSPublicKeyValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPublicKey) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPublicKey) Free() {
	panic("")
}

// NewFilBLSPublicKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPublicKeyRef(ref unsafe.Pointer) *FilBLSPublicKey {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPublicKey) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPublicKey) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPublicKey) Deref() {
	panic("")
}

// allocFilPrivateKeyPublicKeyResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPrivateKeyPublicKeyResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPrivateKeyPublicKeyResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyPublicKeyResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyPublicKeyResponse) Free() {
	panic("")
}

// NewFilPrivateKeyPublicKeyResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyPublicKeyResponseRef(ref unsafe.Pointer) *FilPrivateKeyPublicKeyResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyPublicKeyResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyPublicKeyResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyPublicKeyResponse) Deref() {
	panic("")
}

// allocFilPrivateKeySignResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPrivateKeySignResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPrivateKeySignResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeySignResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeySignResponse) Free() {
	panic("")
}

// NewFilPrivateKeySignResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeySignResponseRef(ref unsafe.Pointer) *FilPrivateKeySignResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeySignResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeySignResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeySignResponse) Deref() {
	panic("")
}

// allocFilSealCommitPhase1ResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilSealCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilSealCommitPhase1ResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase1Response) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase1Response) Free() {
	panic("")
}

// NewFilSealCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase1ResponseRef(ref unsafe.Pointer) *FilSealCommitPhase1Response {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase1Response) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase1Response) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase1Response) Deref() {
	panic("")
}

// allocFilSealCommitPhase2ResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilSealCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilSealCommitPhase2ResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase2Response) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase2Response) Free() {
	panic("")
}

// NewFilSealCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase2ResponseRef(ref unsafe.Pointer) *FilSealCommitPhase2Response {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase2Response) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase2Response) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase2Response) Deref() {
	panic("")
}

// allocFilSealPreCommitPhase1ResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilSealPreCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilSealPreCommitPhase1ResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase1Response) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase1Response) Free() {
	panic("")
}

// NewFilSealPreCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase1ResponseRef(ref unsafe.Pointer) *FilSealPreCommitPhase1Response {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase1Response) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase1Response) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase1Response) Deref() {
	panic("")
}

// allocFilSealPreCommitPhase2ResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilSealPreCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilSealPreCommitPhase2ResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase2Response) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase2Response) Free() {
	panic("")
}

// NewFilSealPreCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase2ResponseRef(ref unsafe.Pointer) *FilSealPreCommitPhase2Response {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase2Response) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase2Response) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase2Response) Deref() {
	panic("")
}

// allocFilStringResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilStringResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilStringResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilStringResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilStringResponse) Free() {
	panic("")
}

// NewFilStringResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilStringResponseRef(ref unsafe.Pointer) *FilStringResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilStringResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilStringResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilStringResponse) Deref() {
	panic("")
}

// allocFilUnsealRangeResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilUnsealRangeResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilUnsealRangeResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilUnsealRangeResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilUnsealRangeResponse) Free() {
	panic("")
}

// NewFilUnsealRangeResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilUnsealRangeResponseRef(ref unsafe.Pointer) *FilUnsealRangeResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilUnsealRangeResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilUnsealRangeResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilUnsealRangeResponse) Deref() {
	panic("")
}

// allocFilVerifySealResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilVerifySealResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilVerifySealResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifySealResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifySealResponse) Free() {
	panic("")
}

// NewFilVerifySealResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifySealResponseRef(ref unsafe.Pointer) *FilVerifySealResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifySealResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifySealResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifySealResponse) Deref() {
	panic("")
}

// allocFilVerifyWindowPoStResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilVerifyWindowPoStResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilVerifyWindowPoStResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyWindowPoStResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyWindowPoStResponse) Free() {
	panic("")
}

// NewFilVerifyWindowPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyWindowPoStResponseRef(ref unsafe.Pointer) *FilVerifyWindowPoStResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyWindowPoStResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyWindowPoStResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyWindowPoStResponse) Deref() {
	panic("")
}

// allocFilVerifyWinningPoStResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilVerifyWinningPoStResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilVerifyWinningPoStResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyWinningPoStResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyWinningPoStResponse) Free() {
	panic("")
}

// NewFilVerifyWinningPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyWinningPoStResponseRef(ref unsafe.Pointer) *FilVerifyWinningPoStResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyWinningPoStResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyWinningPoStResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyWinningPoStResponse) Deref() {
	panic("")
}

// allocFilWriteWithAlignmentResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilWriteWithAlignmentResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilWriteWithAlignmentResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithAlignmentResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithAlignmentResponse) Free() {
	panic("")
}

// NewFilWriteWithAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithAlignmentResponseRef(ref unsafe.Pointer) *FilWriteWithAlignmentResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithAlignmentResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithAlignmentResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithAlignmentResponse) Deref() {
	panic("")
}

// allocFilWriteWithoutAlignmentResponseMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilWriteWithoutAlignmentResponseMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilWriteWithoutAlignmentResponseValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithoutAlignmentResponse) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithoutAlignmentResponse) Free() {
	panic("")
}

// NewFilWriteWithoutAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithoutAlignmentResponseRef(ref unsafe.Pointer) *FilWriteWithoutAlignmentResponse {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithoutAlignmentResponse) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithoutAlignmentResponse) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithoutAlignmentResponse) Deref() {
	panic("")
}

// allocFilPublicPieceInfoMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPublicPieceInfoMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPublicPieceInfoValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPublicPieceInfo) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPublicPieceInfo) Free() {
	panic("")
}

// NewFilPublicPieceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPublicPieceInfoRef(ref unsafe.Pointer) *FilPublicPieceInfo {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPublicPieceInfo) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPublicPieceInfo) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPublicPieceInfo) Deref() {
	panic("")
}

// allocFil32ByteArrayMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFil32ByteArrayMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFil32ByteArrayValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fil32ByteArray) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fil32ByteArray) Free() {
	panic("")
}

// NewFil32ByteArrayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFil32ByteArrayRef(ref unsafe.Pointer) *Fil32ByteArray {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fil32ByteArray) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fil32ByteArray) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fil32ByteArray) Deref() {
	panic("")
}

// allocFilPrivateReplicaInfoMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPrivateReplicaInfoValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateReplicaInfo) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateReplicaInfo) Free() {
	panic("")
}

// NewFilPrivateReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateReplicaInfoRef(ref unsafe.Pointer) *FilPrivateReplicaInfo {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateReplicaInfo) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateReplicaInfo) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateReplicaInfo) Deref() {
	panic("")
}

// allocFilPublicReplicaInfoMemory allocates memory for type interface{} in C.
// The caller is responsible for freeing the this memory via interface{}.
func allocFilPublicReplicaInfoMemory(n int) unsafe.Pointer {
	panic("")
}

const sizeOfFilPublicReplicaInfoValue = unsafe.Sizeof([1]interface{}{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPublicReplicaInfo) Ref() interface{} {
	panic("")
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPublicReplicaInfo) Free() {
	panic("")
}

// NewFilPublicReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPublicReplicaInfoRef(ref unsafe.Pointer) *FilPublicReplicaInfo {
	panic("")
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPublicReplicaInfo) PassRef() (interface{}, *cgoAllocMap) {
	panic("")
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPublicReplicaInfo) PassValue() (interface{}, *cgoAllocMap) {
	panic("")
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPublicReplicaInfo) Deref() {
	panic("")
}

// unpackArgSFilPublicPieceInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFilPublicPieceInfo(x []FilPublicPieceInfo) (unpacked interface{}, allocs *cgoAllocMap) {
	panic("")
}

// packSFilPublicPieceInfo reads sliced Go data structure out from plain C format.
func packSFilPublicPieceInfo(v []FilPublicPieceInfo, ptr0 interface{}) {
	panic("")
}

// unpackArgSFilPrivateReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFilPrivateReplicaInfo(x []FilPrivateReplicaInfo) (unpacked interface{}, allocs *cgoAllocMap) {
	panic("")
}

// packSFilPrivateReplicaInfo reads sliced Go data structure out from plain C format.
func packSFilPrivateReplicaInfo(v []FilPrivateReplicaInfo, ptr0 interface{}) {
	panic("")
}

// unpackArgSFilPublicReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFilPublicReplicaInfo(x []FilPublicReplicaInfo) (unpacked interface{}, allocs *cgoAllocMap) {
	panic("")
}

// packSFilPublicReplicaInfo reads sliced Go data structure out from plain C format.
func packSFilPublicReplicaInfo(v []FilPublicReplicaInfo, ptr0 interface{}) {
	panic("")
}

// unpackArgSFilPoStProof transforms a sliced Go data structure into plain C format.
func unpackArgSFilPoStProof(x []FilPoStProof) (unpacked interface{}, allocs *cgoAllocMap) {
	panic("")
}
